#PSI4 Input File Template for starting a molecule pickle
memory 8000 mb

import sys
sys.path.append('..')
import numpy as np
import MolData
import cPickle as pickle
import merge_amplitudes

#Spatial orbital limit for FCI solution
fci_limit = 15

molecule mol {
H	2.27048018592	0.737723732313	0.0
H	1.9313858055	1.40323392568	0.0
H	1.40323392568	1.9313858055	0.0
H	0.737723732313	2.27048018592	0.0
H	1.46181443719e-16	2.38732414638	0.0
H	-0.737723732313	2.27048018592	0.0
H	-1.40323392568	1.9313858055	0.0
H	-1.9313858055	1.40323392568	0.0
H	-2.27048018592	0.737723732313	0.0
H	-2.38732414638	2.92362887439e-16	0.0
H	-2.27048018592	-0.737723732313	0.0
H	-1.9313858055	-1.40323392568	0.0
H	-1.40323392568	-1.9313858055	0.0
H	-0.737723732313	-2.27048018592	0.0
H	-4.38544331158e-16	-2.38732414638	0.0
H	0.737723732313	-2.27048018592	0.0
H	1.40323392568	-1.9313858055	0.0
H	1.9313858055	-1.40323392568	0.0
H	2.27048018592	-0.737723732313	0.0
H	2.38732414638	-5.84725774878e-16	0.0


 symmetry c1
}

set globals {
  basis sto-3g
  num_amps_print 100000
  freeze_core false
  maxiter 750
  fail_on_maxiter false
  scf_type pk
  df_scf_guess false
  guess sad
  r_convergence 1e-6
  d_convergence 1e-6
  e_convergence 1e-6
  opdm true
  tpdm true
}

#SCF - Do it first, otherwise nothing initializes

#Check for non-singlet spin
set reference rohf
hf_energy, hf_wfn = energy('scf', return_wfn=True)
multiplicity = mol.multiplicity()
if (multiplicity == 1):
   set reference rhf
   hf_energy, hf_wfn = energy('scf', return_wfn=True)

#Basis set information
g_basis = hf_wfn.basisset()
#for i in range(g_basis.nbf()):
#    center_id = g_basis.function_to_center(i)
#    shell_id = g_basis.function_to_shell(i)
#    shell = g_basis.shell(shell_id)
#    shell_am = shell.am
#    shell_exps = [shell.exp(j) for j in range(shell.nfunction)]
#    shell_min_exp = np.min(shell_exps)
#    pos = (mol.x(center_id), mol.y(center_id), mol.z(center_id))

#Molecule Information
n_electrons = 0
charge = mol.molecular_charge()
n_atoms = mol.natom()
for i in range(n_atoms):
    n_electrons += int(mol.Z(i))
n_electrons -= charge
xyz_str = mol.save_string_xyz()

#Orbitals 
canonical_orbitals = hf_wfn.Ca()
orbital_energies = hf_wfn.epsilon_a()
M = canonical_orbitals.rows(0)
fock_matrix = hf_wfn.Fa()

#Integrals
nuc_rep = mol.nuclear_repulsion_energy()
mints = MintsHelper(hf_wfn.basisset())
overlap = mints.ao_overlap()
kinetic = mints.ao_kinetic()
nuclear = mints.ao_potential()
tei = mints.ao_eri()


#MP2 Calc (if/else fixes seg fault glitch for H2+)
#mp2_energy = energy('mp2') if n_electrons > 1 else None

#CISD Energy
try:
    set qc_module detci
    cisd_energy, cisd_wfn = energy('cisd', return_wfn=True)
except:
    cisd_energy, cisd_wfn = None, None

density_wfn = cisd_wfn
if (cisd_wfn is not None):
    #Signature: get_opdm(I,J,"A" OR "B" OR "SUM", FULL_SPACE) for roots I, J, spin "A" or "B", and full space
    opdm_array_a = np.array(density_wfn.get_opdm(0,0,"A",True))
    opdm_array_b = np.array(density_wfn.get_opdm(0,0,"B",True))
    #Signature get_tpdm("AA" or "AB" or "BB", SYMMETRIZE) for spins "AA" etc. and SYMMETRIZE for SUM only
    tpdm_array_aa = np.array(density_wfn.get_tpdm("AA",False))
    tpdm_array_ab = np.array(density_wfn.get_tpdm("AB",False))
    tpdm_array_bb = np.array(density_wfn.get_tpdm("BB",False))

#CC Calc
try:
    set qc_module ccenergy
    ccsd_energy = energy('ccsd')
except:
    ccsd_energy = None

#FCI Calc
#set qc_module detci
if (M - hf_wfn.nfrzc() < fci_limit):
   try:
       fci_energy = energy('fci')
   except:
       fci_energy = None
else:
   fci_energy = None

#Store the relevant info

def matrix_to_np_array(X):
    """Convert Psithon matrix into numpy array"""
    N = X.rows(0)
    arr = np.zeros((N, N))
    for i in range(N):
    	for j in range(N):
	    arr[i,j] = X.get(i,j)
    return arr

def vec_to_np_array(X):
    """Convert Psithon vector into numpy array"""
    N = X.dim(0)
    arr = np.zeros(N)
    for i in range(N):
    	arr[i] = X.get(i)
    return arr

mol_data = MolData.MolData()

#Scalars
mol_data.M_ = M
mol_data.charge_ = charge
mol_data.Z_ = [mol.Z(i) for i in range(n_atoms)]
mol_data.nAtoms_ = n_atoms
mol_data.multiplicity_ = multiplicity
mol_data.nElectrons_ = n_electrons
mol_data.nFrozen_ = hf_wfn.nfrzc()
mol_data.nuclearRepulsion_ = nuc_rep
mol_data.SCFEnergy_ = hf_energy
#mol_data.MP2Energy_ = mp2_energy
mol_data.CISDEnergy_ = cisd_energy

#Basis set information
mol_data.basisToAtom_ = [g_basis.function_to_center(i) 
		           for i in range(g_basis.nbf())]

#Density Matrices
if (cisd_wfn is not None):
    mol_data.CISD_OPDM_A_ = opdm_array_a.reshape(M,M)
    mol_data.CISD_OPDM_B_ = opdm_array_b.reshape(M,M)
    mol_data.CISD_TPDM_AA_ = tpdm_array_aa.reshape(M,M,M,M)
    mol_data.CISD_TPDM_AB_ = tpdm_array_ab.reshape(M,M,M,M)
    mol_data.CISD_TPDM_BB_ = tpdm_array_bb.reshape(M,M,M,M)


mol_data.CCSDEnergy_ = ccsd_energy
mol_data.FCIEnergy_ = fci_energy

#Integrals
mol_data.overlap_ = matrix_to_np_array(overlap)
mol_data.kinetic_ = matrix_to_np_array(kinetic)
mol_data.nuclear_ = matrix_to_np_array(nuclear)
mol_data.totalCore_ = mol_data.kinetic_ + mol_data.nuclear_
mol_data.orbitalEnergies_ = vec_to_np_array(orbital_energies)
mol_data.canonicalOrbitals_ = matrix_to_np_array(canonical_orbitals)
mol_data.fockMatrix_ = matrix_to_np_array(fock_matrix)

#Two Electron Integrals
mol_data.twoElectron_ = matrix_to_np_array(tei).reshape((M,M,M,M))

#Molecule and Metadata
mol_data.xyz_ = xyz_str

#Dump to pickle
pickle_name = "HRing20_sto-3g.pkl"
pickle.dump( mol_data, open(pickle_name, "wb" ) )

#Merge CC Ampltudes into file by parsing
output_filename = outfile_name()
merge_amplitudes.merge_amplitudes(output_filename, pickle_name)